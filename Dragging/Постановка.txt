Задача по Frontend (Senior), которую проходят в некоторых собесах (и не только) в самых сложных или верховных компаниях...
Придумай такой drag & drop в JS и CSS который работает практически без единой осечки, где --drag-x и --drag-y это координаты относительно точки опоры, не считая самой таковой. При этом следует учесть, что...

- Допустимы математические операции в CSS (calc, min, max и прочие), custom properties и даже `@property`... 
- Иногда может потребоваться merge --drag-x, и --drag-y в одну, и обнулением --drag-x и --drag-y после процедуры. 
- Иногда, если происходит округление конечного результата слияния (подобие по grid), и нужно это про-анимировать. 
- В данном контексте почти или практически нет ограничений на поддержку браузерами, главное чтобы это было (в основном) от Chrome 128 версии и выше. 
- Сами эти --drag-x и --drag-y предварительно вливаются в inset или translate на уровне CSS, но пока не JS.
- Если происходит drag and drop с начала, нужно перерасчитать начальную координату --drag-x и --drag-y, и не брать с уже действующего (так как иногда возможны неприятные ошибки). 
- Иногда к clientX и clientY может потребоваться корректировка по отношению к scroll позициям, а также иногда учёт по (--)zoom (если он есть у documentElement). 
- Может потребоваться поддержка touch и даже multi-touch (1 объект или элемент, один палец).
- Значения --drag-x и --drag-y по типу соответствуют `<number>`, хотя при расчёте в CSS умножаются на 1px.
- "Взятие" должно происходить после 100ms задержки (с момента pointerdown, сдвиг на пару пикселей раньше времени ни к чем не приведёт), и инициация только после смещения курсора на пару пикселей. 
- Должна быть максимальная структурированность и даже модульность всего кода. 
- Также должно быть ограничение как по отношению к родителю или контейнеру, и с учётом размера самого элемента. 
- Если есть ещё альтернативные возможные решения или варианты, большую их часть (наиболее оптимальные) можно выписать в блоках комментариев. 
- Если я ошибся в своей задаче, постановке или есть трудности с интерпритацией, прошу указать эти неточности.
- Наиболее оптмимальный вид событий - Pointer events. 
- Если речь идёт о применении DOM элемента в качестве ключа Set или Map, то следует использовать WeakSet или WeakMap. 
- Желательный язык - TypeScript и SCSS, для HTML кода возможны некоторые улучшения, а стандарт от 2024 или 2023 года. 
- Учитывать факторы direction (ltr, rtl), writing-mode, и прочие (влияющие на inline/block).
- Учитывать такой аспект как margin, border, padding, scrollbar и `box-sizing`.
- Доступны и ResizeObserver если они нужны для оптимизаций. 
- Желательные некоторые оптимизации (для избегания некоторых пере-расчётов). 
- Любое вписывание в элемент сторонних свойств элементов (не связанные с атрибутами или нативом) вписывать через Symbol() ключ.

Также возможны варианты событий (при поправке относительной позиции): 
- Элемент с WxH в центре родителя изначально.
- Элемент с WxH в центре контейнера изначально.
- Элемент в левом верхнем углу (по умолчанию), либо по отношению к родителю (по умолчанию), либо к контейнеру (при некоторых `position`).

В стандартах JS/CSS от 2024 года доступно свойства у элементов `currentCSSZoom` (доступно от Chrome 128 версии, и Firefox 126 версии).
