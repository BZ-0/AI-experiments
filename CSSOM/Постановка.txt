Вопрос на тему JS и CSSOM. Одновременно и "простой" и крайне сложнейший.

Раньше существовала функция `webkitConvertPointFromPageToNode`, `convertPointFromPageToNode`, `webkitConvertPointFromNodeToPage`, а также существует в стандарте W3C как `GeometryUtils.convertPointFromNode`
Сторонние библиотека для матриц и векторов в данной задаче не желательны, а потому не доступны по умолчанию.

Эти функции преобразуют pageX, pageY (либо clientX, clientY) в координаты внутри элемента (не просто даже относительно), причём даже с учётом трансформаций или искажений.

Нужно практически полностью ре-имплементировать данные функции... (в том числе и под Chrome, и под Firefox).
Доступны: 
- Средства CSSOM (включая матрицы в точки), Math (в JS), CSS Typed OM (если доступны в браузере), и средства Canvas 2D (если нужны). 
- getComputedStyle, и все свойства элементов.
- Все нативные решения браузеров (в основном Chrome и Firefox).
- Может потребоваться всё: offsetTop, offsetLeft, getBoundingClientRect... 
- Может потребоваться перебирать DOM от child до всех parent по цепочкам.
- Может потребоваться учёт позиций по scrollTop, scrollLeft.
- Может потребоваться учёт не только по transform, но и по transform-origin, `translate:`, `scale:`, `rotate:` и прочие... нужен даже учёт `perspective`. 
- Желательные некоторые оптимизации (для избегания некоторых пере-расчётов). 
- Также придётся учитывать такой аспект как margin, border, padding, scrollbar и `box-sizing`.
- Доступны и ResizeObserver если они нужны для оптимизаций. 
- matrix2d (как матрица mat2x3, но точно в этом не уверен) может быть преобразован в условные mat3, и как следствие в mat4, просто подставляя (например "0,0,1") и прочие.
- Желательно использование TypeScript, также код нужно максимально структурировать, оформить, сделать достаточно модульным. 
- Если есть случаи альтернативных решений некоторых кейсов или задач, можно выписать отдельно или в блоки комментариев в самом коде. 
- Если речь идёт о применении DOM элемента в качестве ключа Set или Map, то следует использовать WeakSet или WeakMap. 
- Даже придётся учитывать факторы direction (ltr, rtl), writing-mode, и прочие (влияющие на inline/block).
- У некоторых элементов может быть параметр CSS `zoom`, и это тоже придётся в ряде случаев учесть (особенно учитывая последние стандарты).
- Любое вписывание в элемент сторонних свойств элементов (не связанные с атрибутами или нативом) вписывать через Symbol() ключ.

В стандартах JS/CSS от 2024 года доступно свойства у элементов `currentCSSZoom` (доступно от Chrome 128 версии, и Firefox 126 версии).
